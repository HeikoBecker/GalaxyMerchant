package GalaxyMerchant.runtime;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class Env {
  private Map<String, Number> values;
  private Map<Ore, Float> conversions;

  public Env() {
    this.values = MapSequence.fromMap(new HashMap<String, Number>());
    this.conversions = MapSequence.fromMap(new HashMap<Ore, Float>());
  }

  public void addBinding(String name, Number value) {
    MapSequence.fromMap(this.values).put(name, value);
  }

  public void addConversion(Ore ore, float value) {
    MapSequence.fromMap(this.conversions).put(ore, value);
  }

  public Number lookupName(String name) {
    return MapSequence.fromMap(this.values).get(name);
  }

  public float lookupConversion(Ore ore) {
    return MapSequence.fromMap(this.conversions).get(ore);
  }

  public static int valOf(Number num) {
    switch (num) {
      case I:
        return 1;
      case V:
        return 5;
      case X:
        return 10;
      case L:
        return 50;
      case C:
        return 100;
      case D:
        return 500;
      case M:
        return 1000;
      default:
        // TODO: Error should never happen!
        return 0;
    }
  }

  private static boolean shouldSub(Number n1, Number n2) {
    return valOf(n1) < valOf(n2);
  }

  private static boolean validSub(Number n1, Number n2) {
    return (n1 == Number.I && (n2 == Number.V || (n2 == Number.X))) || (n1 == Number.X && (n2 == Number.L || n2 == Number.C));
  }

  private static boolean validOccur(Number n, int occur) {
    return ((n == Number.I || n == Number.X || n == Number.C || n == Number.M) && occur <= 3) || ((n == Number.V || n == Number.L || n == Number.D) && (occur == 1));
  }

  private static class Pair<A, B> {
    public A a;
    public B b;
    public Pair(A a, B b) {
      this.a = a;
      this.b = b;
    }
  }

  private static Pair<Integer, List<Number>> consumeNums(List<Number> nums, Number arg, Integer occur) {
    if (ListSequence.fromList(nums).first() == arg) {
      return consumeNums(ListSequence.fromList(nums).tailListSequence(1), arg, occur + 1);
    } else {
      return new Pair<Integer, List<Number>>(occur, nums);
    }
  }

  public static int sum(List<Number> nums) {
    if (ListSequence.fromList(nums).count() == 0) {
      return 0;
    } else {
      Number head = ListSequence.fromList(nums).first();
      Pair<Integer, List<Number>> occurNumsPair = consumeNums(ListSequence.fromList(nums).tailListSequence(1), head, 1);
      if (ListSequence.fromList(occurNumsPair.b).count() == 0) {
        // corner case: nothing left
        if (!((validOccur(head, occurNumsPair.a)))) {
          // TODO:Error
          return 0;
        }
        return occurNumsPair.a * valOf(head);
      }
      Number next = ListSequence.fromList(occurNumsPair.b).first();
      if (!((validOccur(head, occurNumsPair.a)))) {
        // TODO Error
        return 0;
      }
      if (shouldSub(head, next)) {
        if (validSub(head, next) && occurNumsPair.a == 1) {
          Pair<Integer, List<Number>> occurNumsPair2 = consumeNums(ListSequence.fromList(occurNumsPair.b).tailListSequence(1), next, 1);
          if (occurNumsPair2.a == 1) {
            return (valOf(next) - valOf(head)) + sum(occurNumsPair2.b);
          } else {
            // TODO:Error
            return 0;
          }
        }
      } else {
        return (valOf(head) * occurNumsPair.a) + sum(occurNumsPair.b);
      }
      // DEAD CODE
      return 0;
    }
  }


}
